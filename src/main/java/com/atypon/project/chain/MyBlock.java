package com.atypon.project.chain;

import com.atypon.project.transaction.MyTransaction;

import java.io.Serializable;
import java.sql.Timestamp;
import java.util.*;

// TODO addBlock a method to verify the block

/**
 * This class represents the block ,it's the base unit of building the block-chain
 *
 * @author Osama Abuhamdan
 */

public final class MyBlock implements Serializable, Block {

    private static final long serialVersionUID = 741997_741997_741997L;

    // transactions in MyBlock
    private transient final List<MyTransaction> transactions;

    /**
     * @serialFields
     */
    // how many zeroes to be @ the first of the hash
    private static final int DIFFICULTY = 3;

    // block info
    private int blockNumber;

    private final Timestamp creationDate;
    private String blockHash;
    private String previousBlockHash;
    private MyBlock nextBlock;
    private int nonce;

    /**
     * Create the block with arrayList of transactions and creation timestamp
     */
    public MyBlock() {
        this.transactions = new ArrayList<>();
        this.creationDate = new Timestamp(System.currentTimeMillis());
    }

    /**
     * @return block hash
     */
    String getBlockHash() {
        return blockHash;
    }

    /**
     * Give every block a specific number which is its order in the chain.
     *
     * @param number block order in the chain
     */
    void setBlockNumber(int number) {
        this.blockNumber = number;
    }

    /**
     * Set next block previous hash to the current hash
     *
     * @param hash the current hash
     */
    private void setNextBlockPreviousHash(String hash) {
        if (nextBlock != null)  //end of chain reached
            nextBlock.previousBlockHash = hash;
    }

    /**
     * Set the previous block of this block depends on its place in the chain
     * if it's the first block then it's previous block is null
     *
     * @param parent this block previous block
     */
    void setParent(MyBlock parent) {
        if (parent != null) {   //parent equals null only for the first block on the chain
            previousBlockHash = parent.blockHash;
            parent.nextBlock = this;
        } else {
            previousBlockHash = null;
        }
    }

    /**
     * Calculate the hash of the block using SHA-265 hashing function
     * the hashing function inputs are creation date,blockNumber , root of the merkle tree
     * prev hash and nonce
     */
    public void calculateHash() {
        String combinedData = concatenateData();
        String hash = ProofOfWork.calculateProofOfWork(combinedData, DIFFICULTY);
        readNonce();
        setNextBlockPreviousHash(hash);
        this.blockHash = hash;
    }

    /**
     * Read the nonce value given by proof of work algorithm and save it in nonce variable
     */
    private void readNonce() {
        nonce = ProofOfWork.getNonce();
    }

    /**
     * Concatenate the information of the block together
     *
     * @return String represents concatenated data
     */
    private String concatenateData() {
        StringBuilder concatenated = new StringBuilder();
        MerkleTree.buildTree(transactions);

        return concatenated.append(blockNumber)
                .append(String.valueOf(creationDate))
                .append(previousBlockHash)
                .append(MerkleTree.getRoot())
                .toString();
    }

    /**
     * Add transactions to the arrayList of transactions.
     *
     * @param transaction transactions generated by the user.
     */
    public void addTransaction(MyTransaction transaction) {
        if (transaction == null) return;

        if (!transaction.verifySignature()) {
            // Elliptic curve used with the signature
            System.out.println("Signature wasn't verified");
        }

        transactions.add(transaction);

        System.out.println("Transaction Successfully added to Block");
    }


    @Override
    public int hashCode() {
        return Objects.hash(transactions, blockNumber, creationDate, blockHash, previousBlockHash, nextBlock, nonce);
    }

    /**
     * @param o the block to compare with
     * @return true if the blocks hashes are equal
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MyBlock b = (MyBlock) o;
        return this.blockHash.equals(b.blockHash);
    }

    @Override
    public String toString() {
        return "Block{" + '\n' +
                "blockNumber=" + blockNumber + '\n' +
                "creationDate=" + creationDate + '\n' +
                "blockHash=" + blockHash + '\n' +
                "previousBlockHash=" + previousBlockHash + '\n' +
                "nonce=" + nonce + '\n' +
                "difficulty=" + DIFFICULTY + '\n' +
                '}';
    }
}