package com.atypon.project.transaction;

import com.atypon.project.chain.BlockChain;
import com.atypon.project.exception.NoEnoughFundsException;

import java.math.BigDecimal;
import java.security.*;
import java.security.spec.ECGenParameterSpec;
import java.util.*;


// TODO Upgrade the wallet to become more realistic

/**
 * Represents a wallet
 *
 * @author Osama Abuhamdan
 */
public final class MyWallet implements Wallet {

    // to be used to sign transactions done by this wallet
    private PrivateKey privateKey;

    // to be used to verify transactions done by this wallet
    private PublicKey publicKey;

    private BigDecimal balance;

    // UTXOs owned by this wallet
    private Map<String, TransactionOutput> UTXOs = new HashMap<>();

    /**
     * Generate public and private keys on the creation of the wallet.
     */
    public MyWallet() {
        generateKeyPair();
    }

    /**
     * @return private key generated by this wallet
     */
    private PrivateKey getPrivateKey() {
        return privateKey;
    }

    /**
     * @return public key generated by this wallet
     */
    public PublicKey getPublicKey() {
        return publicKey;
    }

    /**
     * @return Money this wallet own
     */
    public BigDecimal getBalance() {
        calculateBalance();
        return balance;
    }

    // elliptic Curve KeyPair
    private void generateKeyPair() {
        try {
            Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("ECDSA", "BC");
            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
            ECGenParameterSpec ecSpec = new ECGenParameterSpec("prime192v1");

            // Initialize the key generator and generate a KeyPair
            keyGen.initialize(ecSpec, random);   //256 bytes provides an acceptable security level
            KeyPair keyPair = keyGen.generateKeyPair();

            // Set the public and private keys from the keyPair
            privateKey = keyPair.getPrivate();
            publicKey = keyPair.getPublic();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    /**
     * Calculate balance by check the main ledger contents , if it have UTXOs of this wallet
     * they will be its.
     */
    private void calculateBalance() {
        BigDecimal total = new BigDecimal(0);
        for (Map.Entry<String, TransactionOutput> item : BlockChain.UTXOs.entrySet()) {
            TransactionOutput UTXO = item.getValue();

            // if UTXO belongs to this wallet (if coins belong to me)
            if (UTXO.isMine(publicKey)) {
                // addBlock it to this wallet list of unspent transactions
                UTXOs.put(UTXO.getId(), UTXO);
                total = total.add(UTXO.getValue());
            }
        }

        this.balance = total;
    }

    /**
     * Send money to other wallet by spending UTXOs belongs to this wallet.
     *
     * @param recipient MyWallet to send money to.
     * @param value     to be sent
     * @return transaction represents this money transfer
     * @throws NoEnoughFundsException when user try to send money more than he have
     */
    public MyTransaction sendFunds(MyWallet recipient, BigDecimal value) {
        if (getBalance().compareTo(value) < 0) {
            throw new NoEnoughFundsException();
        }

        // get enough inputs to handle this transfer
        List<TransactionInput> inputs = getTransactionInputs(value);

        MyTransaction newTransaction = new MyTransaction(this, recipient, value, inputs);

        // sign this transaction
        newTransaction.generateSignature(privateKey);

        // remove spent money from this wallet UTXOs list
        for (TransactionInput input : inputs) {
            UTXOs.remove(input.getTransactionOutputId());
        }

        //process the transaction
        newTransaction.processTransaction();

        System.out.println(value + " was sent");
        return newTransaction;
    }

    /**
     * Iterate on UTXOs to get enough money to handle the transaction
     *
     * @param value to get to make the transaction
     * @return ArrayList of inputs to complete the transaction
     */
    private List<TransactionInput> getTransactionInputs(BigDecimal value) {
        List<TransactionInput> inputs = new LinkedList<>();

        BigDecimal total = new BigDecimal(0);

        for (Map.Entry<String, TransactionOutput> item : UTXOs.entrySet()) {
            TransactionOutput UTXO = item.getValue();
            total = total.add(UTXO.getValue());
            inputs.add(new TransactionInput(UTXO.getId()));

            if (total.compareTo(value) > 0) break;
        }
        return inputs;
    }


    /**
     * Buy money for the wallet from an imaginary wallet.
     *
     * @param value to bought from the imaginary wallet
     * @return transaction represents money buying.
     */
    public MyTransaction buyNewCoins(BigDecimal value) {

        // imaginary wallet to send money from.
        MyWallet coinBase = new MyWallet();

        // no inputs because no one sends money to coinBase wallet
        MyTransaction transaction = new MyTransaction(coinBase, this, value, null);

        // sign the transaction by the imaginary wallet private key
        transaction.generateSignature(coinBase.getPrivateKey());

        transaction.getOutputs().add(new TransactionOutput(this.getPublicKey(), value, transaction.getTransactionId()));

        // addBlock this money to the main ledger
        // its important to store our first transaction in the UTXOs list
        BlockChain.UTXOs.put(transaction.getOutputs().get(0).getId(), transaction.getOutputs().get(0));

        return transaction;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MyWallet wallet = (MyWallet) o;
        return Objects.equals(privateKey, wallet.privateKey) &&
                Objects.equals(publicKey, wallet.publicKey) &&
                Objects.equals(balance, wallet.balance) &&
                Objects.equals(UTXOs, wallet.UTXOs);
    }

    @Override
    public int hashCode() {
        return Objects.hash(privateKey, publicKey);
    }

}